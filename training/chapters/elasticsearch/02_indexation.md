---
layout: cover
---

# Indexing

---

# Creating an Index

* A document is indexed within an `index`.
* For backward compatibility, a `_doc` type is associated with it.
* When indexing the first document, Elasticsearch will deduce the document's structure.
* It's important not to leave this default structure.
* Retrieve this generated configuration to modify it later.

---

# Indexing a Document

* A document is defined in JSON format.

```
POST /movies/_doc
{
    "title": "Titanic"
}
```

---

# Indexing a Document

* Here is the response to the previous request.

```
{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "mQ6jknEBOjsOKzV3MVdi",
  "_version" : 1,
  "result" : "created",
  "_shards" : {
    "total" : 2,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 0,
  "_primary_term" : 1
}
```

---

# Indexing a Document

* During indexing, an `_id` will be generated by Elasticsearch (configurable).
* After indexing, the document is searchable within a second (`refresh_interval`).
* It is recommended to increase or disable this property during bulk indexing.

---

# Indexing a Document

* It is possible to use the `POST` verb and provide the document identifier.

```
POST /movies/_doc/myId
{
    "title": "Titanic"
}
```

---

# Retrieving a Document

* We can retrieve a document using a `GET` request.

```
GET /movies/_doc/mQ6jknEBOjsOKzV3MVdi
```

```
{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "mQ6jknEBOjsOKzV3MVdi",
  "_version" : 1,
  "_seq_no" : 0,
  "_primary_term" : 1,
  "found" : true,
  "_source" : {
    "title" : "Titanic"
  }
}
```

---

# Updating a Document

* We can update a document using a `PUT` request.

```
PUT /movies/_doc/mQ6jknEBOjsOKzV3MVdi
{
    ...
}
```

```
{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "mQ6jknEBOjsOKzV3MVdi",
  "_version" : 2,
  "result" : "updated",
  "_shards" : {
    "total" : 2,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 1,
  "_primary_term" : 1
}
```

---

# Updating a Document

* Caution, this update is total, and the previous document will be completely overwritten.
* It is possible to perform partial updates using the `_update` API.

```
POST movies/_update/mQ6jknEBOjsOKzV3MVdi
{
  "doc": {
    "year": 1998
  }
}
```

---

# Deleting a Document

* We can delete a document using a `DELETE` request.

```
DELETE /movies/_doc/mQ6jknEBOjsOKzV3MVdi
```

```
{
  "_index" : "movies",
  "_type" : "_doc",
  "_id" : "mQ6jknEBOjsOKzV3MVdi",
  "_version" : 3,
  "result" : "deleted",
  "_shards" : {
    "total" : 2,
    "successful" : 1,
    "failed" : 0
  },
  "_seq_no" : 2,
  "_primary_term" : 1
}
```

---

# Retrieving All Indexed Documents

* Using the `_search` endpoint
* Default display of the first 10 documents
* We can define a simple query using the `q` query parameter
* Definition of sorting and pagination using the `sort`, `size`, and `from` query parameters
* Possibility to define more complex queries

---

# First Search

```
POST /movies/_search?q=titanic
```

```
{
  "took" : 1536,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1,
      "relation" : "eq"
    },
    "max_score" : 0.14874382,
    "hits" : [
      {
        "_index" : "movies",
        "_type" : "_doc",
        "_id" : "mQ6jknEBOjsOKzV3MVdi",
        "_score" : 0.14874382,
        "_source" : {
          "title" : "Titanic"
        }
      }
    ]
  }
}
```

---

# First Search

```
POST /movies/_search?q=title:titanic

POST /movies/_search?q=title:titanic&size=5

POST /movies/_search?q=title:titanic&size=5&from=10

POST /movies/_search?q=title:titanic&sort:title
```

---

# Index Management

* We can create indexes manually

```
PUT /movies
{
    "settings" : {
        ...
    },
    "mappings" : {
        ...
    },
    "aliases": {
        ...
    }
}
```

* Mappings and aliases will be presented soon.

---

# Index Management

* In the `settings` part, we define the **shards** of our index.
* Two types of shards exist:
    * **Primary shards** and **replica shards**
* **Primary shards** are used first during indexing.
* **Primary** and **replicas** are used similarly during search.
* A shard corresponds to a Lucene instance.

---

# Index Management

```
PUT /movies
{
    "settings" : {
        "number_of_shards" : 3,
        "number_of_replicas" : 2
    }
}
```

---

# Index Management

* We can modify certain *settings* of an index afterward.

```
PUT /movies/_settings
{
    "index" : {
        "number_of_replicas" : 2
    }
}
```

---

# Index Management

* A global configuration can be defined in the `elasticsearch.yml` file.

```
index.number_of_shards: 1
index.number_of_replicas: 1
```

---

# Cluster Status

* Elasticsearch will create shards and place them correctly.
* A shard replica cannot be on the same node as a primary shard.
* If it is the case, the cluster status will be `yellow`.
* The cluster can have the status `green`, `yellow`, or `red`.

```
GET /_cluster/health
```

--- 

# Cluster Status

```
{
  "cluster_name" : "testcluster",
  "status" : "yellow",
  "timed_out" : false,
  "number_of_nodes" : 1,
  "number_of_data_nodes" : 1,
  "active_primary_shards" : 1,
  "active_shards" : 1,
  "relocating_shards" : 0,
  "initializing_shards" : 0,
  "unassigned_shards" : 1,
  "delayed_unassigned_shards": 0,
  "number_of_pending_tasks" : 0,
  "number_of_in_flight_fetch": 0,
  "task_max_waiting_in_queue_millis": 0,
  "active_shards_percent_as_number": 50.0
}
```

---

# Cluster Status

![](/images/cluster_yellow.png)

---

# Cluster Status

![](/images/cluster_green.png)

---

# Index Management

* We can delete an index

```
DELETE /movies
```

* We can delete multiple indexes

```
DELETE /movies,albums
```

---

# Index Management

* We can also delete all indexes :(

```
DELETE _all
```

* It is recommended to disable this potential loophole in the `elasticsearch.yml` file.

```
action.disable_delete_all_indices: true
```

---


# Introduction to Bulk API in Elasticsearch

- The Bulk API allows for indexing or updating multiple documents in a single request, which significantly improves performance compared to individual document indexing.

- Each action within a bulk request needs to be specified on a separate line, followed by the document (for index and update actions) on the next line. 

- Supported actions include `index`, `create`, `delete`, and `update`.

---

# Example of a Bulk Index Request

- Example of a bulk request that indexes two documents into the `products` index.

```json
POST /_bulk
{ "index" : { "_index" : "products", "_id" : "1" } }
{ "name" : "Coffee", "price" : 10.5 }
{ "index" : { "_index" : "products", "_id" : "2" } }
{ "name" : "Tea", "price" : 9.5 }
```
```json
{
  "took": 30,
  "errors": false,
  "items": [
    {"index": {"_index": "products", "_id": "1", "status": 201}},
    {"index": {"_index": "products", "_id": "2", "status": 201}}
  ]
}
```

--- 

# Handling Errors and Best Practices

- Handling Errors in Bulk Requests
  - Even if one or more actions fail, the bulk operation can still complete successfully for the rest. 
  - Each action's result needs to be checked individually for errors.

---

# Best Practices 

- Best Practices
  - Splitting bulk requests into manageable sizes to avoid overloading the cluster. 
  - A common practice is to keep the size of a bulk request under 15MB.
  - Adjusting the refresh rate temporarily for large ingestions can improve performance.
  - Monitoring the `thread_pool.bulk.queue` and `thread_pool.bulk.rejected` metrics to tune bulk request sizes and intervals.

```http
PUT products/_settings
{
    "refresh_interval": "-1"
}
```

```http
PUT products/_settings
{
    "refresh_interval": "30s"
}
```

---
src: ./chapters/aliases.md
hide: false
---

---
layout: cover
---
# Practical Section
